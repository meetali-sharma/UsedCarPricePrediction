# -*- coding: utf-8 -*-
"""Data Processing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17p1CbLv_5xZYapQ1ltR6SmcWiaydh-1J
"""

import pandas as pd
import numpy as np
import re
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

#importing the file
df = pd.read_excel('Final_output.xlsx')

df.head()

# Find the number of missing values in each column
missing_values = df.isnull().sum()

# Filter to only show columns with missing values
columns_with_missing = missing_values[missing_values > 0]

# Display the result
print("Columns with missing values:")
print(columns_with_missing)

#Doing data transformation and removing unnecessary data
# Iterate through each row in the specified column and manually transform
for i in range(len(df)):
    value = df.loc[i, 'FuelType']  # Access the value in the column
    if len(value) == 3:  # Check if the length of the string is 3
        df.loc[i, 'FuelType'] = value.upper()  # Convert the string to uppercase

# Display the updated DataFrame
df.FuelType.unique()

# Changing Data type for KM
df['KM'] = df['KM'].str.replace(',', '').astype(float)


# Changing Data type for Owners
df['OwnerNo'] = df['OwnerNo'].astype(float)


# Changing Data type for Years
df['ManufacturingYear'] = df['ManufacturingYear'].astype(float)

print('DataFrameUpdated')

#Removing inconsistent data from the Columns
keywords_to_remove = {
    'InsuranceValidity': [' insurance', 'Petrol', '2', 'Diesel', '1', 'Electric'],
    'Mileage' : ['0 CC',	'1061 CC',	'1086 CC',	'1197 CC',	'1332 CC',	'1353 CC',	'1397 CC',	'1451 CC',	'1462 CC',	'1482 CC',	'1493 CC',	'1497 CC',	'1498 CC',	'1950 CC',	'1956 CC',	'1969 CC',	'1984 CC',	'1991 CC',	'1995 CC',	'1997 CC',	'1998 CC',	'1999 CC',	'2112 CC',	'2179 CC',	'2184 CC',	'2198 CC',	'2393 CC',	'2446 CC',	'2487 CC',	'2523 CC',	'2755 CC',	'2894 CC',	'2925 CC',	'2956 CC',	'2987 CC',	'2994 CC',	'2995 CC',	'2996 CC',	'2998 CC',	'2999 CC',	'3346 CC',	'3982 CC',	'998 CC',	'999 CC'],
    'Seats': ['1,20,000 Kms',	'1,29,306 Kms',	'1,32,528 Kms',	'1,32,724 Kms',	'1,67,332 Kms',	'10,000 Kms',	'13,270 Kms',	'14,000 Kms',	'15,000 Kms',	'15,400 Kms',	'19,252 Kms',	'22,421 Kms',	'25,284 Kms',	'30,000 Kms',	'30,428 Kms',	'31,268 Kms',	'35,000 Kms',	'36,349 Kms',	'36,385 Kms',	'37,000 Kms',	'37,942 Kms',	'4,140 Kms',	'40,000 Kms',	'41,200 Kms',	'48,000 Kms',	'5,000 Kms',	'50,000 Kms',	'6,000 Kms',	'60,000 Kms',	'60,611 Kms',	'64,374 Kms',	'65,991 Kms',	'68,767 Kms',	'7,000 Kms',	'7,087 Kms',	'7,800 Kms',	'70,000 Kms',	'73,045 Kms',	'77,032 Kms',	'80,000 Kms',	'81,700 Kms',	'83,045 Kms',	'83,394 Kms',	'86,715 Kms',	'89,545 Kms',	'90,000 Kms',	'95,963 Kms'],
    'RTO': ['First Owner',	'Third Owner',	'Second Owner',	'Fourth Owner',	'Manual',	'Fifth Owner',	'796 cc',	'1999 cc',	'1197 cc',	'998 cc',	'Automatic',	'1799 cc',	'2446 cc',	'999 cc',	'993 cc',	'1061 cc',	'1995 cc'],
    'Color': ['5','6','8'],
    'DriveType': ['4X2',	'5',	'6',	'7',	'4X4',	'Power',	'8',	'Electric',	'7.3sec',	'400',	'10', '.3sec'],
    'Torque' :['11.4 ',	'11.4 kgm at 4,000 rpm',	'17.8 ',	'18',	'19',	'20.4',	'22.9',	'25.1 ',	'25.5',	'25.5 ',	'34.7 ',	'35.7 ',	'R18']
    }

# Function to remove keywords from a string
def remove_keywords(text, keywords):
    if isinstance(text, str):  # Check if the value is a string
        for keyword in keywords:
            text = text.replace(keyword, '')
        return text.strip()  # Remove any leading/trailing spaces
    return text  # If it's not a string, return the original value

# Apply the function to each column based on its specific keywords
for column, keywords in keywords_to_remove.items():
    df[column] = df[column].apply(lambda x: remove_keywords(x, keywords))

print('DataFrameUpdated')

# Function to convert price strings to numeric values
def convert_price(price_str):
    # Handle None and empty strings
    if pd.isna(price_str) or price_str.strip() == '':
        return None

    # Remove currency symbol and whitespace
    price_str = price_str.replace('â‚¹', '').strip()

    # Initialize the numeric value
    numeric_value = 0

    # Check if 'Lakh' or 'Crore' is in the string
    if 'Lakh' in price_str:
        parts = price_str.split(' ')
        if len(parts) >= 2:
            value = parts[0]  # Get the numeric value
            try:
                numeric_value = float(value) * 100000  # Convert Lakh to its numerical equivalent
            except ValueError:
                return None  # Handle conversion errors
    elif 'Crore' in price_str:
        parts = price_str.split(' ')
        if len(parts) >= 2:
            value = parts[0]  # Get the numeric value
            try:
                numeric_value = float(value) * 10000000  # Convert Crore to its numerical equivalent
            except ValueError:
                return None  # Handle conversion errors

    return numeric_value  # Return the converted numeric value

# Apply the conversion function to the 'Price' column
df['Numeric_Price'] = df['CarPrice'].apply(convert_price)
df['Numeric_Actual_Price'] = df['ActualPrice'].apply(convert_price)
df['Numeric_Saving_Price'] = df['SavingPrice'].apply(convert_price)

print('DataFrameUpdated')


# Function to clean non-numeric and invalid year values from EngineDisplacement
def clean_engine_displacement(value):
    # Check if the value is a string and is not numeric or contains non-numeric entries
    if isinstance(value, str):
        # Remove entries like 'Manual', 'Automatic', or purely non-numeric values
        if 'Manual' in value or 'Automatic' in value or not re.match(r'^\d{3,4} cc$', value):
            return None
    elif isinstance(value, (int, float)) and (value in [2010, 2014, 2015, 2018]):
        # Remove invalid year values
        return None
    return value  # Return valid engine displacement values



# Function to clean non-numeric and invalid year values from EngineDisplacement
def clean_engine_displacement(value):
    if isinstance(value, str):
        if 'Manual' in value or 'Automatic' in value or not re.match(r'^\d{3,4} cc$', value):
            return None  # Remove invalid entries
    elif isinstance(value, (int, float)) and (value in [2010, 2014, 2015, 2018]):
        return None  # Remove invalid year values
    return value  # Keep valid engine displacement

# Apply the function to clean the EngineDisplacement column
df['EngineDisplacement'] = df['EngineDisplacement'].apply(clean_engine_displacement)

# Function to update missing EngineDisplacement values from Engine column
bhp_pattern = r'\d+(\.\d+)?bhp'  # BHP regex pattern

def update_missing_engine_displacement(row):
    engine_displacement = row['EngineDisplacement']
    engine = row['Engine']

    # Check if EngineDisplacement is missing and Engine is valid (not bhp or blank)
    if pd.isnull(engine_displacement) and isinstance(engine, str) and engine != '' and not re.search(bhp_pattern, engine):
        return engine  # Replace with valid Engine value if applicable
    return engine_displacement  # Keep the original value if valid

# Apply the function to update missing EngineDisplacement values from the Engine column
df['EngineDisplacement'] = df.apply(update_missing_engine_displacement, axis=1)

# Reapply the clean function to ensure all invalid entries are removed
df['EngineDisplacement'] = df['EngineDisplacement'].apply(clean_engine_displacement)

# Function to extract numeric value before 'CC' or 'cc' in the EngineDisplacement column
def extract_cc_value(value):
    if isinstance(value, str):  # Ensure the value is a string
        match = re.search(r'(\d+(\.\d+)?)\s?[Cc][Cc]', value)  # Regex to capture number before 'CC' or 'cc'
        if match:
            return float(match.group(1))  # Return the numeric value as float
    return None  # Return None if no match is found

# Apply the function to extract numeric value before 'CC'
df['EngineDisplacement_CC'] = df['EngineDisplacement'].apply(extract_cc_value)

# Display the final DataFrame with the new column
print("Final EngineDisplacement and EngineDisplacement_cc columns:")
print(df[['EngineDisplacement', 'EngineDisplacement_CC']].head())

# To take bhp values
# Function to extract numeric value before 'bhp'
def extract_bhp_value(value):
    if isinstance(value, str):  # Ensure the value is a string
        match = re.search(r'(\d+(\.\d+)?)bhp', value)  # Regex to capture number before 'bhp'
        if match:
            return float(match.group(1))  # Return the numeric value as float
    return None  # Return None if no match is found

# Apply the function to the 'MaxPower' column
df['MaxPower_BHP'] = df['MaxPower'].apply(extract_bhp_value)

# Display the updated DataFrame
print(df[['MaxPower', 'MaxPower_BHP']].head())

# Function to extract numeric value before 'NM' or 'nm' in the Torque column
def extract_nm_value(value):
    if isinstance(value, str):  # Ensure the value is a string
        match = re.search(r'(\d+(\.\d+)?)\s?[Nn][Mm]', value)  # Regex to capture number before 'Nm' or 'NM'
        if match:
            return float(match.group(1))  # Return the numeric value as float
    return None  # Return None if no match is found

# Apply the function to the 'Torque' column
df['Torque_NM'] = df['Torque'].apply(extract_nm_value)

# Display the updated DataFrame with the new column
print(df[['Torque', 'Torque_NM']].head())

# Function to extract numeric value before 'kmpl' in the Mileage column
def extract_kmpl_value(value):
    if isinstance(value, str):  # Ensure the value is a string
        match = re.search(r'(\d+(\.\d+)?)\s?kmpl', value)  # Regex to capture number before 'kmpl'
        if match:
            return float(match.group(1))  # Return the numeric value as float
    return None  # Return None if no match is found

# Apply the function to the 'Mileage' column
df['Mileage_KMPL'] = df['Mileage'].apply(extract_kmpl_value)

# Display the updated DataFrame with the new column
print(df[['Mileage', 'Mileage_KMPL']].head())

# List of columns you want to drop
columns_to_drop = ['IgnitionType','ActualPrice','SavingPrice','CarPrice','RTO','EngineDisplacement', 'Mileage', 'Engine', 'MaxPower', 'Torque', 'MaxPower.1', 'MaxTorque']

# Drop only the columns that exist in the DataFrame
df = df.drop(columns=[col for col in columns_to_drop if col in df.columns], axis=1)

# Print a message after dropping columns
print('Columns Dropped')


#To make DriveType column consistent, replaceing muliple values with standard values
replace_value = {'2 WD':'2WD','4x2' : '2WD',	'4' : '4WD',	'Front Wheel Drive' : 'FWD',	'Rear Wheel Drive with ESP' : 'RWD',	'Two Wheel Drive' : '2WD',	'4x4' : '4WD',	'AWD INTEGRATED MANAGEMENT' : 'AWD',	'All Wheel Drive' : 'AWD',	'2' : '2WD',	'RWD(with MTT)' : 'RWD',	'Permanent all-wheel drive quattro' : 'AWD',	'4 WD' : '4WD',}
df['DriveType'] = df['DriveType'].replace(replace_value)

#replacing blanks with nan
df = df.apply(lambda x: x.str.strip() if isinstance(x, str) else x).replace('', np.nan)

df.DriveType.unique()

# TO standardize the color in VIBGYOR format
replace_value = { 'BEIGE':'Yellow','golden brown':'Brown','Outback Bronze':'Brown', 'G Brown':'Brown','Carnelian Red Pearl':'Red','Tafeta White':'White','Silky silver':'Silver', 'Modern Steel Metallic':'Grey', 'chill':'White','beige':'Yellow','GOLDEN BROWN':'Brown','Silky Silver':'Silver','Polar White':'White','Yellow':'BEIGE','Neutral':'White','Golden brown':'Brown','White' : 'White',	'Red' : 'Red',	'Others' : 'White',	'Gray' : 'Grey',	'Grey' : 'Black',	'Maroon' : 'Violet',	'Orange' : 'Orange',	'Silver' : 'Silver',	'Blue' : 'Blue',	'Brown' : 'Brown',	'Yellow' : 'Yellow',	'Black' : 'Black',	'Golden' : 'Yellow',	'Green' : 'Green',	'O Purple' : 'Violet',	'Other' : 'White',	'Gold' : 'Yellow',	'TITANIUM GREY' : 'Grey',	'Violet' : 'Violet',	'MODERN STEEL METALLIC' : 'Grey',	'PLATINUM WHITE' : 'White',	'Golden Brown' : 'Orange',	'Aurora Black Pearl' : 'Black',	'Beige' : 'Yellow',	'Star Dust' : 'Yellow',	'Flash Red' : 'Red',	'Purple' : 'Violet',	'PLATINUM WHITE PEARL' : 'White',	'Wine Red' : 'Red',	'Taffeta White' : 'White',	'Minimal Grey' : 'Grey',	'Fiery Red' : 'Red',	'T Wine' : 'Red',	'Prime Star Gaze' : 'Blue',	'TAFETA WHITE' : 'White',	'P Black' : 'Black',	'METALL' : 'Black',	'MET ECRU BEIGE' : 'Yellow',	'COPPER' : 'Orange',	'TITANIUM' : 'Grey',	'CHILL' : 'White',	'Burgundy' : 'Violet',	'Lunar Silver Metallic' : 'Silver',	'SILKY SILVER' : 'Silver',	'BERRY RED' : 'Red',	'PREMIUM AMBER METALLIC' : 'Orange',	'R EARTH' : 'Yellow',	'PLATINUM SILVER' : 'Silver',	'ORCHID WHITE PEARL' : 'White',	'CARNELIAN RED PEARL' : 'Red',	'POLAR WHITE' : 'White',	'Medium Blue' : 'Blue',	'Alabaster Silver Metallic' : 'Silver',	'Carbon Steel' : 'Silver',	'Cavern Grey' : 'Silver',	'ESPRESO_BRWN' : 'Brown',	'Pearl White' : 'White',	'Magma Grey' : 'Grey',	'Dark Red' : 'Red',	'Falsa Colour' : 'White',	'Cherry' : 'Red',	'Hip Hop Black' : 'Black',	'Nexa Blue' : 'Blue',	'Passion Red' : 'Red',	'Cirrus White' : 'White',	'Arizona Blue' : 'Blue',	'Galaxy Blue' : 'Blue',	'Modern Steel Metal' : 'Grey',	'Burgundy Red Metallic' : 'Red',	'magma gray' : 'Grey',	'CBeige' : 'Yellow',	'Goldan BRWOON' : 'Orange',	'm grey' : 'Grey',	'b red' : 'Red',	'Granite Grey' : 'Grey',	'urban titanim' : 'Grey',	'g brown' : 'Brown',	'Rosso Brunello' : 'Orange',	'a silver' : 'Silver',	'b grey' : 'Grey',	'Radiant Red M' : 'Red',	'c bronze' : 'Orange',	'Champagne Mica Metallic' : 'Yellow',	'Bold Beige Metallic' : 'Yellow',	'Starry Black' : 'Black',	'Sleek Silver' : 'Silver',	'Symphony Silver' : 'Silver',	'Phantom Black' : 'Black',	'Metallic Magma Grey' : 'Grey',	'c brown' : 'Brown',	'Metallic Glistening Grey' : 'Grey',	'Superior white' : 'White',	'Arctic Silver' : 'Silver',	'Urban Titanium Metallic' : 'Silver',	'Smoke Grey' : 'Grey',	'Pearl Arctic White' : 'White',	'Bright Silver' : 'Silver',	'Porcelain White' : 'White',	'Coral White' : 'White',	'Diamond White' : 'White',	'Brick Red' : 'Red',	'Mediterranean Blue' : 'Blue',	'Mist Silver' : 'Silver',	'Gravity Gray' : 'Grey',	'Candy White' : 'White',	'Metallic Premium silver' : 'Silver',	'Glistening Grey' : 'Grey',	'Super white' : 'White',	'Deep Black Pearl' : 'Indigo',	'Twilight Blue' : 'Indigo',	'Caviar Black' : 'Black',	'Pearl Met. Arctic White' : 'White',	'Metallic silky silver' : 'Silver',	'Pure white' : 'White',	'StarDust' : 'Yellow',	'Alabaster Silver Metallic - Amaze' : 'Blue',	'Ray blue' : 'Blue',	'Glacier White Pearl' : 'Blue',	'OUTBACK BRONZE' : 'Orange',	'Solid Fire Red' : 'Red',	'Daytona Grey' : 'Grey',	'Metallic Azure Grey' : 'Grey',	'Moonlight Silver' : 'Silver',	'Fire Brick Red' : 'Red',	'Cashmere' : 'White',	'Pearl Snow White' : 'White',	'Light Orange' : 'Orange',	'Foliage' : 'Green',	'Sky Blue' : 'Blue',	'Off White' : 'White',	'Bronze' : 'Orange',	'Parpel' : 'Violet',	'Cherry Red' : 'Red',	'Sunset Red' : 'Red',	'Silicon Silver' : 'Silver',	'Dark Blue' : 'Blue',	'Technometgrn+Gryroof' : 'Grey',	'Light Silver' : 'Silver',	'Out Back Bronze' : 'Orange'}
df['Color'] = df['Color'].replace(replace_value)

#replacing blanks with nan
df = df.apply(lambda x: x.str.strip() if isinstance(x, str) else x).replace('', np.nan)
df.Color.unique()

# Extract the numeric part of the 'Seats' column using a regular expression.

df['Seats'] = df['Seats'].str.extract('(\d+)')

# Convert the column to numeric, handling errors by coercing invalid values to NaN
df['Seats'] = pd.to_numeric(df['Seats'], errors='coerce')

# Now convert the column to int, filling NaN with a suitable value (e.g., 0)
df['Seats'] = df['Seats'].fillna(df['Seats'].mode()[0]).astype(int)
df['Seats'].head()

# Find the number of missing values in each column
missing_values = df.isnull().sum()

# Filter to only show columns with missing values
columns_with_missing = missing_values[missing_values > 0]

# Display the result
print("Columns with missing values:")
print(columns_with_missing)

""" Updating missing value for body type """

df.loc[3382, 'BodyType'] = 'MUV'
df.loc[5390, 'BodyType'] = 'Minivan'
df.loc[5411, 'BodyType'] = 'Minivan'
df.loc[8114, 'BodyType'] = 'Minivan'

""" Updating missing value for insurance validity """
mode=df['InsuranceValidity'].mode()[0]
df['InsuranceValidity'] = df['InsuranceValidity'].fillna(mode)

""" Updating missing value for seats """
mode=df['Seats'].mode()[0]
df['Seats'] = df['Seats'].fillna(mode)

""" Updating missing value for Color  """
mode=df['Color'].mode()[0]
df['Color'] = df['Color'].fillna(mode)

""" Updating missing value for DriveType  """
mode=df['DriveType'].mode()[0]
df['DriveType'] = df['DriveType'].fillna(mode)


""" Updating missing value for Numeric_Actual_Price  """
mean=df['Numeric_Actual_Price'].mean()
df['Numeric_Actual_Price'] = df['Numeric_Actual_Price'].fillna(mean)


""" Define a function to calculate saving price to fill missing values"""
def calculate_saving_price(row):
    car_price = row['Numeric_Price']
    actual_price = row['Numeric_Actual_Price']

    # If Car Price is greater than or equal to Actual Price, calculate saving price
    if car_price >= actual_price:
        return car_price - actual_price
    else:
        # where Car Price is less than Actual Price ( set Saving Price to 0)
        return 0

# Apply the function to the DataFrame to fill the SavingPrice column
df['Numeric_Saving_Price'] = df.apply(calculate_saving_price, axis=1)


""" Updating missing value for EngineDisplacement_CC  """
mode=df['EngineDisplacement_CC'].mode()[0]
df['EngineDisplacement_CC'] = df['EngineDisplacement_CC'].fillna(mode)


""" Updating missing value for MaxPower_BHP  """
median=df['MaxPower_BHP'].median()
df['MaxPower_BHP'] = df['MaxPower_BHP'].fillna(median)


""" Updating missing value for Torque_NM   """
median=df['Torque_NM'].median()
df['Torque_NM'] = df['Torque_NM'].fillna(median)


""" Updating missing value for Mileage_KMPL   """
mode=df['Mileage_KMPL'].mode()[0]
df['Mileage_KMPL'] = df['Mileage_KMPL'].fillna(mode)

mode=df['Mileage_KMPL'].mode()[0]
print(mode)

# Find the number of missing values in each column
missing_values = df.isnull().sum()

# Filter to only show columns with missing values
columns_with_missing = missing_values[missing_values > 0]

# Display the result
print("Columns with missing values:")
print(columns_with_missing)


""" Applying one-hot encoding on categorical columns"""
df.rename(columns={' EquipmentManufacturer': 'EquipmentManufacturer'}, inplace=True)

# One-hot encoding using pandas
df = pd.get_dummies(df, columns=['City', 'FuelType','BodyType','Transmission','EquipmentManufacturer','CarModel','InsuranceValidity','Color','DriveType'])

print(df.columns)

#Saving the pre-processed encoded data in Encoded file
output_file ='Encoded_file.xlsx'
df.to_excel(output_file, index=False)
print(f'DataFrame saved to {output_file}')


#Ploting histogram to analyze the pattern of data (Example: normally distributed or not)
df = pd.read_excel('Encoded_file.xlsx')
# Select numeric columns


numeric_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Create histograms using seaborn
for column in numeric_columns:
    plt.figure(figsize=(8, 4))
    sns.histplot(df[column], kde=True)
    plt.title(f'Histogram of {column}')
    plt.show()

"""As we visualize by ploting histogram for dataset that the data is not normally distributed, so we use **IQR** for Outliers removal and **Min-Max scaling** for normalizing numeric features and not go for Z-Score."""


#Code for detection and removal of outliers

# Load  DataFrame
df = pd.read_excel('Encoded_file.xlsx')

def detect_and_remove_outliers(df):
    # Initialize an empty DataFrame to store outliers
    outliers = pd.DataFrame()

    # Loop through each column in the dataset to detect outliers
    for column in df.select_dtypes(include=['float64', 'int64']).columns:
        # Calculate Q1 (25th percentile) and Q3 (75th percentile)
        Q1 = df[column].quantile(0.25)
        Q3 = df[column].quantile(0.75)
        IQR = Q3 - Q1  # Interquartile range

        # Define the upper and lower bounds
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Identify outliers for the current column
        column_outliers = df[(df[column] < lower_bound) | (df[column] > upper_bound)]
        outliers = pd.concat([outliers, column_outliers])

        # Remove outliers from the original DataFrame
        df = df[~((df[column] < lower_bound) | (df[column] > upper_bound))]

    # Drop duplicates in the outliers DataFrame (since rows can be outliers for multiple columns)
    outliers = outliers.drop_duplicates()

    # Print the number of outliers detected
    print(f"Total outliers detected: {len(outliers)}")

    # Print the number of rows left after removing outliers
    print(f"Rows remaining after removing outliers: {len(df)}")

    return df

# Creating new dataframe by removing outliers
df_cleaned = detect_and_remove_outliers(df)

# Example to show outliers and remaining rows
print("Outliers detected and removed, remaining data:")
print(df_cleaned)

# Filter the DataFrame to remove rows where any value in numeric columns is an outlier
#df_cleaned = df[~((df[numeric_columns] < lower_bound) | (df[numeric_columns] > upper_bound)).any(axis=1)]


""" Normalizing numeric features for further use """

#  df_cleaned is our DataFrame
def apply_min_max_scaling(df_cleaned):
    # Create a MinMaxScaler object
    scaler = MinMaxScaler()

    # Apply Min-Max scaling to the entire DataFrame
    # Only apply scaling to numerical columns (int64, float64)
    numeric_columns = ['KM', 'ManufacturingYear', 'Numeric_Actual_Price',
                   'Numeric_Saving_Price', 'EngineDisplacement_CC', 'MaxPower_BHP',
                   'Torque_NM', 'Mileage_KMPL']

    df_cleaned[numeric_columns] = scaler.fit_transform(df_cleaned[numeric_columns])

    return df_cleaned

# Normalize the data
df_normalized = apply_min_max_scaling(df_cleaned)

# Print the 'Numeric_Actual_Price' column to check if it's normalized correctly
print(df_normalized.head())

output_file ='Clean_file.xlsx'
df_normalized.to_excel(output_file, index=False)
print(f'DataFrame saved to {output_file}')